package blockchain

import (
	"math/rand"
	"strings"
	"testing"
	"time"
)

/**
 * A function that tests the accuracy of generating a hash. Given the same content twice
 * it should produce the same value.
 */
func TestCalculateHashValueAccuracy(t *testing.T) {
	dt := time.Now().String()
	b := Block{
		Index:        1,
		Timestamp:    dt,
		Transactions: []Transaction{},
		PrevHash:     "0",
		Nonce:        3000,
	}
	checkHash := b.CalculateHash()
	if checkHash != b.CalculateHash() {
		t.Errorf("Hash not consistent and would always be invalid: got %s... expected %s...", checkHash[:7], b.CalculateHash()[:7])
	}
}

/**
 * A function that reviews the lengths of the hashes returned by the function are
 * an expected length of 64 characters, although we can increase the size if needed.
 */
func TestCalculateHashHashLength(t *testing.T) {
	dt := time.Now().String()
	b := Block{
		Index:        1,
		Timestamp:    dt,
		Transactions: []Transaction{},
		PrevHash:     "0",
		Nonce:        3000,
	}
	checkHash := b.CalculateHash()
	if len(checkHash) != 64 {
		t.Errorf("Hash is not the proper length: got %d and expected 64", len(checkHash))
	}
}

/**
 * A function that tests that the generated Genesis Block contains a Block index of 0;
 */
func TestCreateGenesisBlockIndex(t *testing.T) {
	gb := CreateGenesisBlock()

	if gb.Index != 0 {
		t.Errorf("Index which was created should be 0 instead it was %d", gb.Index)
	}
}

/**
 * A test that ensures that when a genesis block is linked to a previous hash of 0.
 * if the value is a hash then the blockchain is comprimised.
 */
func TestCreateGenesisBlockPreviousHash(t *testing.T) {
	gb := CreateGenesisBlock()

	if gb.PrevHash != "0" {
		t.Errorf("Previous hash is set to something other than 0, ")
	}
}

/**
 * A function that verifies that the hash generated using the calculate hash function
 * return value is being added to the genesis block without any changing of the data.
 */
func TestCreateGenesisBlockHashLength(t *testing.T) {
	gb := CreateGenesisBlock()

	if len(gb.Hash) != 64 {
		t.Errorf("Hash is not the proper length: got %d and expected 64", len(gb.Hash))
	}
}

/*
*
  - A function that checks that the length of the difficulty is accruate given the
  - parameters provided.

`
*/
func TestGenerateDifficultyLength(t *testing.T) {
	rn := rand.Intn(99999)
	diff := GenerateDifficulty(rn)

	if len(diff) != rn {
		t.Errorf("length of difficulty does not match. Expected %d, got %d", rn, len(diff))
	}
}

/**
 * A unit test to determin if the values generated by function
 * GenerateDifficulty are the string '0' and not some other string value.
 */
func TestGenerateDifficultyValue(t *testing.T) {
	rn := rand.Intn(10)
	diff := strings.Split(GenerateDifficulty(rn), "")
	for i := 0; i < len(diff); i++ {
		if diff[i] != "0" {
			t.Errorf("The character of the difficulty is incorrect. At index %d expected '0' and got %s", i, diff[i])
			return
		}
	}
}
